fl.outputPanel.clear();
var trace = fl.trace;
fl.showIdleMessage(false);

// this runs on every item in the library, so you will need to change the following line to only run on selected items
var runOnAllItems = true;
var runOnAllFiles = false;
var flashDocs = [];

var folderName = fl.getDocumentDOM().path;
folderName = folderName.substring(0, folderName.lastIndexOf("\\"));
folderName = folderName.replace(/\\/g, "/");
folderName = folderName.replace(/:/, "|");
folderName = "file:///" + folderName;

var curDoc;
var pubDoc;
var pubDocPath;
var curFlaPath;
var curFlaName;
var curSymbol;
var curSymbolObj;
var curTimeline;
var curTimelineObj;
var curLayer;
var curFrame;
var curFrameObj;
var curElement;
var resourceFolder = "resources";

var w = [];
var ep; // edgeParser

function main()
{
    var orgDoc = fl.getDocumentDOM();

    var cfDir = fl.configDirectory;
	cfDir = cfDir.replace(/\\/g, "/");
	cfDir = cfDir.replace(/:/, "|");
	cfDir = "file:///" + cfDir;

    fl.runScript(cfDir + "Commands/vectorToJson.jsfl");
    ep = new edgeParser(orgDoc);

	
	pubDoc = fl.createDocument();
	var pp = cfDir + "Publish Profiles/jsflScrape.xml";
	pubDoc.importPublishProfile( pp);
	pubDoc.currentPublishProfile = "jsflScrape";
	
	if(runOnAllFiles)
	{
		findAllFlaFiles(folderName);
		processAllFlaFiles();
	}
	else
	{
		processFla(orgDoc);
	}
	fl.closeDocument(pubDoc, false);
}

function findAllFlaFiles(dir)
{	
	var files = FLfile.listFolder(dir + "/*.fla", "files");
	for(var f = 0; f < files.length; f++)
	{
		flashDocs.push(dir + "/" + files[f]);
	}

    var dirs = FLfile.listFolder(dir, "directories");

    if(dirs != null)
	{
		for(var i = 0; i < dirs.length; i++)
		{
			findAllFlaFiles(dir + "/" + dirs[i]);
		}
	}	
}
function processAllFlaFiles()
{
	for(var i = 0; i < flashDocs.length; i++)
	{
		processFla(flashDocs[i]);
	}
}
function processFla(input)
{
	
	var doc = typeof(input) == "string" ? fl.openDocument(input) : input;
	curDoc = doc;
	
	curFlaPath = doc.path;
	curFlaPath = curFlaPath.substring(0, curFlaPath.lastIndexOf("\\"));
	curFlaPath = curFlaPath.replace(/\\/g, "/");
	curFlaPath = curFlaPath.replace(/:/, "|");	
	curFlaPath = "file:///" + curFlaPath;
	curFlaName = doc.name.substring(0, doc.name.lastIndexOf("."));	
	
	pubDocPath = curFlaPath + "/_.swf";	

	var lib = doc.library;
	
	if(runOnAllItems)
	{
		lib.selectAll();
		lib.expandFolder(true, true);
		lib.selectAll();
	}
	
	//var libTree = processLibrary(doc.library);
	var libTree = objToJson(doc);
	toJson(libTree);	
	//trace(json.join(""));
	
	var uri = folderName + "/" + curFlaName + ".vex";
	FLfile.write(uri, json.join("")) ;
	
	if(runOnAllItems)
	{
		lib.selectAll();
		lib.expandFolder(false, true);
		//lib.selectNone();
	}
	//fl.saveDocument(doc);
	//doc.publish();
	
	//fl.outputPanel.save(folderName + "" + doc.name + ".contents");
	//fl.outputPanel.clear();
	//fl.closeDocument(doc, false);
}


function objToJson(obj)
{
	var isArray = (obj instanceof Array) && (obj.length > 0);
	var testObj = isArray ? obj[0] : obj;
	var lmbd = null;
	
	if(obj instanceof Document)
	{
		lmbd = processDocument;
	}
	else if(obj instanceof Library)
	{
		lmbd = processLibrary;
	}
	else if(testObj instanceof Edge)
	{
		lmbd = isArray ? processEdges : processEdge;
	}
	else if(testObj instanceof Frame)
	{
		lmbd = isArray ? processFrames : processFrame;
	}
	else if(testObj instanceof Layer)
	{
		lmbd = isArray ? processLayers : processLayer;
	}
	else if(testObj instanceof Point)
	{
		lmbd = isArray ? processPoints : processPoint;
	}
	else if(testObj instanceof Shape)
	{
		lmbd = isArray ? processShapes : processShape;
	}
	else if(testObj instanceof SymbolInstance)
	{
		lmbd = isArray ? processSymbolInstances : processSymbolInstance;
	}
	else if(testObj instanceof SymbolItem)
	{
		lmbd = isArray ? processSymbolItems : processSymbolItem;
	}
	else if(testObj instanceof Timeline)
	{
		lmbd = isArray ? processTimelines : processTimeline;
	}
	else
	{
		lmbd = toJson;
	}
	var result = lmbd(obj);
	return result;
}


function processDocument(obj)
{
	var jo = 
	{
		Library:processLibrary(obj.library),
		Root : processTimelines(obj.timelines),
		Settings : processSettings(obj)
	};
	return jo;
}
function processSettings(obj)
{
	return [];
}

function processLibrary(obj)
{	
	curTimeline = "";
	var ar = [];
	var selItems = obj.getSelectedItems();	
	
	for(var c = 0; c < selItems.length; c++)
	{	
		var itm = null;
		switch(selItems[c].itemType)
		{
			case "undefined":
				break;

			case "component":
				itm = processComponent(selItems[c]);
				break;

			case "movie clip":
			case "graphic":
			case "button":
				itm = processSymbolItem(selItems[c]);
				break;

			case "folder":
				itm = processFolder(selItems[c]);
				break;

			case "font":
				//itm = processFont(selItems[c]);
				break;

			case "sound":
				//itm = processSound(selItems[c]);
				break;

			case "bitmap":
				//itm = processBitmap(selItems[c]);			
				break;

			case "compiled clip":
				//itm = processCompiled clip(selItems[c]);
				break;

			case "screen":
				//itm = processScreen(selItems[c]);
				break;

			case "video":
				//itm = processVideo(selItems[c]);
				break;
		}
		if(itm != null)
		{
			ar.push(itm);
		}
	}
	
	return {Items:ar};
}

function processFolder(obj)
{
}
function processComponent(obj)
{
}
function isDefaultScaleGrid(gr)
{
	return (gr.left == -2147483.648 &&
			gr.top == -2147483.648 && 
			gr.right == -2147483.648 &&
			gr.bottom == -2147483.648	);
}
function processSymbolItem(obj)
{
	curSymbol = obj.name;
	curSymbolObj = obj;
	curDoc.library.editItem(curSymbol);
	trace("curSymbol " + curSymbol);
	var jo = 
	{
		Timeline:processTimeline(obj.timeline),
		SymbolType : obj.symbolType,
		SourceFilePath : obj.sourceFilePath,
		SourceLibraryName : obj.sourceLibraryName,
		SourceAutoUpdate : obj.sourceAutoUpdate,
		ScalingGrid : obj.scalingGrid ? true : null,
		ScalingGridRect : isDefaultScaleGrid(obj.scalingGridRect) ? null : obj.scalingGridRect,
		ItemType : obj.itemType,
		Name : obj.name,
		LinkageExportForAS : obj.linkageExportForAS ? true : null,
		LinkageExportForRS : obj.linkageExportForRS ? true : null,
		LinkageImportForRS : obj.linkageImportForRS ? true : null,
		LinkageExportInFirstFrame : obj.linkageExportInFirstFrame,
		LinkageIdentifier : obj.linkageIdentifier,
		LinkageClassName : obj.linkageClassName,
		LinkageBaseClass : obj.linkageBaseClass,
		LinkageURL : obj.linkageURL
	};
	return jo;
}
function processFont(obj)
{
}
function processSound(obj)
{
}
function processBitmap(obj)
{
}
function processCompiledClip(obj)
{
}
function processScreen(obj)
{
}
function processVideo(obj)
{
}


function processTimelines(obj)
{
	var ar = [];
	for(var i = 0; i < obj.length; i++)
	{
		curTimeline = obj.name; // only root level timelines have names (scenes)
		var l = processTimeline(obj[i]);
		ar.push(l);
	}
	return ar;
}

function processTimeline(obj)
{
	curTimelineObj = obj;
	var jo = 
	{
		Name : obj.name,
		Layers : processLayers(obj.layers),
		FrameCount : obj.frameCount,
		CurrentFrame : obj.currentFrame,
		LayerCount : obj.layerCount,
		CurrentLayer : obj.currentLayer
	}
	return jo;
}

function processLayers(obj)
{
	var ar = [];
	for(var i = 0; i < obj.length; i++)
	{
		curLayer = i;
		var l = processLayer(obj[i]);
		ar.push(l);
	}
	return ar;
}
function processLayer(obj)
{
	var isLocked = obj.locked;
	var isVisible = obj.visible;
	obj.locked = false;
	obj.visible = true;
	var jo = 
	{
		LayerIndex : curLayer,
		Name : obj.name,
		LayerType : obj.layerType != "normal" ? obj.layerType : null,
		Visible : isVisible ? null : false,
		Locked : isLocked ? true : null,
		FrameCount : obj.frameCount,
		Frames : processFrames(obj.frames),
		Color : obj.color,
		Height : obj.height,
		Outline : obj.outline ? true : null,
		ParentLayer : obj.parentLayer
	}
	obj.locked = isLocked;
	obj.visible = isVisible;
	return jo;
}

function processFrames(obj)
{
	var ar = [];
	for(var i = 0; i < obj.length; i++)
	{
		curFrame = i;
		curFrameObj = obj[i];
		var f = processFrame(obj[i]);
		ar.push(f);
	}
	return ar;
}
function processFrame(obj)
{	
	curDoc.selected = obj;
	curDoc.selectNone();
	
	var hasSound = obj.soundLibraryItem == null;
	var hasTween = obj.tweenType == "none";

	var jo = 
	{
		LayerIndex : curLayer,
		FrameIndex : curFrame,
		Name : obj.name,
		ActionScript : obj.actionScript,
		Elements : processElements(obj.elements),
		StartFrame : obj.startFrame,
		Duration : obj.duration,
		SoundLibraryItem : hasSound == null ? null : obj.soundLibraryItem,
		SoundEffect : obj.soundEffect == "none" ? null : obj.soundEffect,
		SoundName : hasSound == null ? null : obj.soundName,
		SoundSync : hasSound == null ? null : obj.soundSync,
		SoundLoopMode : hasSound ? null : obj.soundLoopMode,
		SoundLoop : hasSound ? null : obj.soundLoop,
		TweenType : hasTween ? null : obj.tweenType,
		TweenEasing : hasTween ? null : obj.tweenEasing,
		MotionTweenScale : obj.motionTweenScale ? null : false,
		MotionTweenRotate : obj.motionTweenRotate == "auto" ? null : obj.motionTweenRotate,
		MotionTweenRotateTimes : obj.motionTweenRotateTimes == 0 ? null : obj.motionTweenRotateTimes,
		MotionTweenOrientToPath : obj.motionTweenOrientToPath ? true : null,
		MotionTweenSync : obj.motionTweenSync ? true : null,
		MotionTweenSnap : obj.motionTweenSnap ? true : null,
		ShapeTweenBlend : obj.shapeTweenBlend == "distributive" ? null : obj.shapeTweenBlend,
		LabelType : obj.labelType == "none" ? null : obj.labelType,
		HasCustomEase : obj.hasCustomEase ? true : null,
		UseSingleEaseCurve : obj.useSingleEaseCurve ? true : null
	}
	return jo;

}
var curElements;
function processElements(obj)
{
	curElements = obj;
	var ar = [];
	for(var i = 0; i < obj.length; i++)
	{
		curElement = i;
		ar.push(processElement(obj[i]));
	}
	return ar;
}

function exportShape(obj)
{
	var fldr = curFlaPath + "/" + curFlaName + "/" + resourceFolder + "/" + curSymbol;
	fldr = fldr.substring("file:///".length);
	trace(fldr);
	var fldrs = fldr.split("/");
	var f = "file:///";
	for(var i = 0; i < fldrs.length; i++)
	{
		f += fldrs[i] + "/";
		if(!FLfile.exists(f))
		{
			FLfile.createFolder(f);
		}
	}
	var tl = curTimeline == "" ? "" : curTimeline + "_";
	var hash = tl + "L" + curLayer + "F" + curFrame + "D" + obj.depth;	
	var destURI = f  + "" + hash + ".swf";
	
	var wasSel = curElements[curElement].selected;
	curTimelineObj.setSelectedFrames(curFrame, curFrame+1);
	curDoc.selectNone();
	curElements[curElement].selected = true;
	var selArray = curDoc.selection;
	selArray.splice(0);
	selArray.push(curElements[curElement]);
	curElements[curElement].selected = true;
	
	curDoc.selection = [obj];
	curDoc.clipCopy();
	curElements[curElement].selected = wasSel;
	pubDoc.clipPaste();
	
	for (var i = 0; i < pubDoc.library.items.length; i++) 
	{
		var itm = pubDoc.library.items[i];
		if (itm.itemType == "bitmap") 
		{			
			var n = itm.name;
			var sn = "_" + itm.name;
			var en = "_" + itm.name;
			if(!pubDoc.library.itemExists(sn))
			{
				pubDoc.library.selectItem(n);
				pubDoc.library.addItemToDocument({x:3, y:60});
				pubDoc.convertToSymbol("movie clip",sn, "top left");
				pubDoc.deleteSelection();
				
				pubDoc.library.selectItem(sn);
				var itm2 = pubDoc.library.getSelectedItems()[0];
				
				itm2.linkageExportForAS = true;
				itm2.linkageIdentifier = n;
				itm2.linkageExportInFirstFrame = true;	
				itm2.linkageClassName = '';
				itm2.scalingGrid = false;	
			}	
		}
	}
	trace("** done ");
	pubDoc.exportSWF(pubDocPath, true);
	pubDoc.selectAll();
	pubDoc.deleteSelection();
	pubDoc.library.selectAll();
	pubDoc.library.deleteItem();
	
	if(FLfile.exists(destURI))
	{
		FLfile.remove(destURI);
	}
	var suc = FLfile.copy(pubDocPath, destURI);

	if(FLfile.exists(pubDocPath))
	{
		FLfile.remove(pubDocPath);
	}

}
function processElement(obj)
{
//	if(obj.elementType == "shape" && curFrameObj.startFrame == curFrame)
//	{
//		//exportShape(obj);
//        var chains = ep.parseContours(obj.contours);
//        trace(chains);
//        for(var i = 0; i < chains.length; i++)
//        {
//            trace(chains[i].serialize("AS1"));
//        }
//
//    }
	var jo = 
	{
		Loop : obj.loop,
		FirstFrame : obj.firstFrame,
		Locked : obj.locked ? true : null,
		ElementType : obj.elementType,
		Edges : processEdges(obj.edges),
		//Vertices : processVertices(obj.vertices),
		//Contours : processContours(obj.contours),
		IsGroup : obj.isGroup ? true : null,
		IsDrawingObject : obj.isDrawingObject ? true : null,
		IsOvalObject : obj.isOvalObject ? true : null,
		IsRectangleObject : obj.isRectangleObject ? true : null,		
		StartAngle : obj.startAngle,
		EndAngle : obj.endAngle,
		InnerRadius : obj.innerRadius,
		ClosePath : obj.closePath,
		TopLeftRadius : obj.topLeftRadius,
		BottomLeftRadius : obj.bottomLeftRadius,
		TopRightRadius : obj.topRightRadius,
		BottomRightRadius : obj.bottomRightRadius,
		LockFlag : obj.lockFlag,
		Name : obj.name,
		Left : obj.left,
		Top : obj.top,
		Width : obj.width,
		Height : obj.height,
		Matrix : processMatrix(obj.matrix),
		Depth : obj.depth,
		//Layer : obj.layer,
		Selected : obj.selected,
		X : obj.x,
		Y : obj.y,
		TransformX : obj.transformX,
		TransformY : obj.transformY,
		ScaleX : obj.scaleX,
		ScaleY : obj.scaleY,
		SkewX : obj.skewX,
		SkewY : obj.skewY,
		Rotation : obj.rotation,
        Chains : processShape(obj);
    }
	return jo;	
}

function processShape(obj)
{
    var jo = null;
    if(obj.elementType == "shape" && curFrameObj.startFrame == curFrame)
	{
        chains = ep.parseContours(obj.contours);
    }
    return chains;
}
function processEdges(obj)
{
	var result = null;
	if(obj != null)
	{
		result = [];
		for(var i = 0; i < obj.length; i++)
		{
			result.push(processEdge(obj[i]));
		}
	}
	return result;
}
function processEdge(obj)
{
	var jo = 
	{
		Id : obj.id,
		IsLine : obj.isLine,
		V0:processVertex(obj.getControl(0)),
		V1:processVertex(obj.getControl(1)),
		V2:processVertex(obj.getControl(2))
	}
	return jo;
}
function processVertices(obj)
{
	var ar = [];
	for(var i = 0; i < obj.length; i++)
	{
		ar.push(processVertex(obj[i]));
	}
	return ar;
}
function processVertex(obj)
{
	var jo = 
	{
		X : obj.x,
		Y : obj.y
	}
	return jo;
}
function processContours(obj)
{
	var ar = [];
	for(var i = 0; i < obj.length; i++)
	{
		ar.push(processContour(obj[i]));
	}
	return ar;
}
function processContour(obj)
{
	var jo = 
	{	
		HalfEdges : processHalfEdges(obj.getHalfEdge()),
		Orientation : obj.orientation,
		Interior : obj.interior
	}
	return jo;
}

function processHalfEdges(obj)
{
	var startIndex = obj.index;
	var hes = [{Id:obj.id, Index:obj.index}];
	var cur = obj.getNext();
	while(cur != null && cur.index != startIndex)
	{
		hes.push({Id:cur.id, Index:cur.index});
	}
	return hes;
}
function processMatrix(obj)
{
	var jo = 
	{
		A : obj.a,
		B : obj.b,
		C : obj.c,
		D : obj.d,
		Tx : obj.tx,
		Ty : obj.ty
	}
	return jo;
}
var json = [];
function toJson(obj)
{
	var result = true;
	//var bt = obj.toString();
	if(obj == undefined || obj == null)
	{
		//json.push("null");
		result = false;
	}
	else
	{
		var t = typeof(obj);
		switch(t)
		{
			case "object":
				if (obj instanceof Array) //typeof obj.length === 'number' && !(obj.propertyIsEnumerable('length')) ) 
				{
					var comma = "";
					json.push("[");
					for(var i = 0; i < obj.length; i++)
					{
						var val = 
						json.push(comma);
						var suc = toJson(obj[i]);
						if(!suc)
						{
							json.pop();
						}
						else
						{
							comma = ",";
						}
					}
					json.push("]");
				}
				else
				{
					var comma = "";
					json.push("{");
					for(var o in obj)
					{
						json.push(comma + "" + o + ":");
						var suc = toJson(obj[o]);
						if(!suc)
						{
							json.pop();
						}
						else
						{
							comma = ",";
						}
					}
					json.push("}");
				}
				break;
			case "number":
				json.push(obj);
				break;
			case "string":
				if(obj != "")
				{
					json.push("\"" + obj +"\"");
				}
				else
				{
					result = false;
				}
				break;
			case "boolean":
				json.push(obj);
				break;
			default:
				break;
		}
	}
	return result;
}

main();

